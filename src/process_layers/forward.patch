--- ./join_layer/sub_pattern_buffer.rs	2025-03-21 15:16:11.619472177 +0800
+++ ./join_layer/sub_pattern_buffer.rs	2025-03-21 15:16:11.619472177 +0800
@@ -7,7 +7,7 @@
 use std::collections::{BinaryHeap, HashSet};
 use std::rc::Rc;
 
-use super::{get_parent_id, get_sibling_id};
+// use super::{get_parent_id, get_sibling_id};
 
 /// A structure that holds order relations between sibling buffers.
 #[derive(Clone, Debug)]
@@ -79,10 +79,8 @@
 pub struct SubPatternBuffer {
     /// Buffer id.
     pub id: usize,
-    /// Mainly for debugging.
-    sibling_id: usize,
     /// Ids of pattern entities (nodes) contained in this sub-pattern.
-    node_id_list: HashSet<usize>,
+    pub (super) node_id_list: HashSet<usize>,
     /// Ids of pattern events (edges) contained in this sub-pattern.
     edge_id_list: HashSet<usize>,
     /// A buffer that holds sub-pattern matches.
@@ -99,11 +97,9 @@
     pub max_num_events: usize,
 }
 
-// impl<'p> SubPatternBuffer<'p> {
 impl<'p> SubPatternBuffer {
     pub fn new(
         id: usize,
-        sibling_id: usize,
         sub_pattern: &SubPattern,
         max_num_entities: usize,
         max_num_events: usize,
@@ -117,7 +113,6 @@
         }
         Self {
             id,
-            sibling_id,
             node_id_list,
             edge_id_list,
             buffer: BinaryHeap::new(),
@@ -133,7 +128,6 @@
         pattern: &Pattern,
         sub_pattern_buffer1: &SubPatternBuffer,
         sub_pattern_buffer2: &SubPatternBuffer,
-        // distances_table: &HashMap<(NodeIndex, NodeIndex), i32>,
     ) -> Relation {
         let mut shared_entities = vec![false; pattern.entities.len()];
         let mut event_orders = Vec::new();
@@ -166,21 +160,19 @@
         }
     }
 
-    /// Merge two sub-pattern buffers.
+    /// Merge two sub-pattern buffers into a new one.
     pub fn merge_buffers(
         sub_pattern_buffer1: &SubPatternBuffer,
         sub_pattern_buffer2: &SubPatternBuffer,
+        new_buffer_id: usize,
     ) -> Self {
         let mut node_id_list = sub_pattern_buffer1.node_id_list.clone();
         let mut edge_id_list = sub_pattern_buffer1.edge_id_list.clone();
         node_id_list.extend(&sub_pattern_buffer2.node_id_list);
         edge_id_list.extend(&sub_pattern_buffer2.edge_id_list);
 
-        let id = get_parent_id(sub_pattern_buffer1.id);
-
         Self {
-            id,
-            sibling_id: get_sibling_id(id),
+            id: new_buffer_id,
             node_id_list,
             edge_id_list,
             buffer: BinaryHeap::new(),
--- ./unoptimized_join_layer.rs	2025-03-21 15:12:03.621323672 +0800
+++ ./join_layer.rs	2025-03-21 15:13:43.368578661 +0800
@@ -1,12 +1,18 @@
 mod sub_pattern_buffer;
 mod sub_pattern_match;
 
+use crate::pattern::sub_pattern;
 use crate::pattern::Pattern;
 use crate::pattern::SubPattern;
 use crate::pattern_match::PatternMatch;
 use itertools::Itertools;
 use log::debug;
+use std::cmp::max;
+use std::cmp::min;
+use std::cmp::Reverse;
+use std::collections::HashSet;
 use std::collections::{BinaryHeap, HashMap};
+use std::vec;
 pub use sub_pattern_buffer::SubPatternBuffer;
 use sub_pattern_match::EarliestFirst;
 pub use sub_pattern_match::SubPatternMatch;
@@ -34,33 +40,35 @@
     /// Complete pattern matches.
     full_match: Vec<PatternMatch>,
 
+    sibling_id_map: Vec<usize>,
+    parent_id_map: Vec<usize>,
+
     num_states: u64,
 }
 
 impl<'p, P> JoinLayer<'p, P> {
-    /// Create and initialize a pair of sub-pattern buffers.
     fn create_buffer_pair(
-        buffer_id: usize,
+        buffer_id1: usize,
+        buffer_id2: usize,
+        new_buffer_id: usize,
         pattern: &'p Pattern,
-        init_buffers: &mut HashMap<usize, SubPatternBuffer>,
+        sub_pattern_buffers: &mut Vec<SubPatternBuffer>,
     ) {
         let relations = SubPatternBuffer::generate_relations(
             pattern,
-            &init_buffers[&buffer_id],
-            &init_buffers[&(buffer_id + 1)],
+            &sub_pattern_buffers[buffer_id1],
+            &sub_pattern_buffers[buffer_id2],
         );
 
         // update
-        init_buffers.get_mut(&buffer_id).unwrap().relation = relations.clone();
-        init_buffers.get_mut(&(buffer_id + 1)).unwrap().relation = relations;
+        sub_pattern_buffers[buffer_id1].relation = relations.clone();
+        sub_pattern_buffers[buffer_id2].relation = relations;
 
-        init_buffers.insert(
-            get_parent_id(buffer_id),
-            SubPatternBuffer::merge_buffers(
-                &init_buffers[&buffer_id],
-                &init_buffers[&(buffer_id + 1)],
-            ),
-        );
+        sub_pattern_buffers.push(SubPatternBuffer::merge_buffers(
+            &sub_pattern_buffers[buffer_id1],
+            &sub_pattern_buffers[buffer_id2],
+            new_buffer_id,
+        ));
     }
     pub fn new(
         prev_layer: P,
@@ -70,16 +78,14 @@
     ) -> Self {
         let buffer_len = 2 * sub_patterns.len() - 1;
         let mut sub_pattern_buffers = Vec::with_capacity(buffer_len);
-        let mut init_buffers = HashMap::new();
+        let mut sibling_id_map = vec![0usize; buffer_len];
+        let mut parent_id_map = vec![0usize; buffer_len];
 
         for (i, sub_pattern) in sub_patterns.iter().enumerate() {
-            debug!("pattern.entities.len(): {}", pattern.entities.len());
-            let buffer_id = get_buffer_id(i, buffer_len);
-            init_buffers.insert(
-                buffer_id,
+            let buffer_id = i;
+            sub_pattern_buffers.push(
                 SubPatternBuffer::new(
                     buffer_id,
-                    get_sibling_id(buffer_id),
                     sub_pattern,
                     pattern.entities.len(),
                     pattern.events.len(),
@@ -87,12 +93,61 @@
             );
         }
 
-        for buffer_id in (1..buffer_len - 1).step_by(2).rev() {
-            Self::create_buffer_pair(buffer_id, pattern, &mut init_buffers);
+        let mut union_find = UnionFind::new(buffer_len);
+
+        let mut joined = vec![false; buffer_len];
+
+        let mut min_heap = BinaryHeap::new();
+        let shared_node_lists = Self::gen_shared_node_lists(sub_patterns);
+        for (i, list) in shared_node_lists.iter().enumerate() {
+            for j in list {
+                // avoid duplicates
+                if *j <= i {
+                    continue;
+                }
+                min_heap.push(Reverse((2u32, i, *j)));
+            }
         }
 
-        for buffer_id in 0..buffer_len {
-            sub_pattern_buffers.push(init_buffers[&buffer_id].clone());
+        while let Some(Reverse((height, i, j))) = min_heap.pop() {
+            if joined[i] || joined[j] {
+                continue;
+            }
+
+            joined[i] = true;
+            joined[j] = true;
+
+            let new_buffer_id = sub_pattern_buffers.len();
+            Self::create_buffer_pair(i, j, new_buffer_id, pattern, &mut sub_pattern_buffers);
+            sibling_id_map[i] = j;
+            sibling_id_map[j] = i;
+            parent_id_map[i] = new_buffer_id;
+            parent_id_map[j] = new_buffer_id;
+
+            debug!("buffer {} and buffer {} are merged into buffer {}", i, j, new_buffer_id);
+
+            union_find.merge(i, j, new_buffer_id);
+
+            let mut visited = HashSet::new();
+            visited.insert(new_buffer_id);
+            for k in 0..sub_patterns.len() {
+                let cur_root = union_find.get_root(k);
+                if visited.contains(&cur_root) {
+                    continue;
+                }
+
+                // there might be duplicate `cur_root`
+                for id in &shared_node_lists[k] {
+                    // has shared node relation
+                    if union_find.get_root(*id) == new_buffer_id {
+                        let new_height = max(height, union_find.get_height(cur_root)) + 1;
+                        min_heap.push(Reverse((new_height, new_buffer_id, cur_root)));
+
+                        visited.insert(cur_root);
+                        break;
+                    }
+                }
+            }
         }
 
         Self {
@@ -101,12 +156,45 @@
             sub_pattern_buffers,
             window_size,
             full_match: Vec::new(),
+            sibling_id_map,
+            parent_id_map,
             num_states: 0,
         }
     }
 
+    fn gen_shared_node_lists(sub_patterns: &[SubPattern<'p>]) -> Vec<Vec<usize>> {
+        let mut shared_node_lists = vec![Vec::new(); sub_patterns.len()];
+        for (i, sub_pattern1) in sub_patterns.iter().enumerate() {
+            let entity_ids1: HashSet<usize> = sub_pattern1
+                .events
+                .iter()
+                .flat_map(|e| [e.subject.id, e.object.id])
+                .collect();
+            for (j, sub_pattern2) in sub_patterns.iter().enumerate() {
+                if j <= i {
+                    continue;
+                }
+                let entity_ids2: HashSet<usize> = sub_pattern2
+                    .events
+                    .iter()
+                    .flat_map(|e| [e.subject.id, e.object.id])
+                    .collect();
+                // let entity_ids2 = sub_pattern2.events.iter().flat_map(|e| [e.subject.id, e.object.id]).sorted().unique().collect_vec();
+
+                if Self::has_shared_node(&entity_ids1, &entity_ids2) {
+                    shared_node_lists[i].push(j);
+                    shared_node_lists[j].push(i);
+                }
+            }
+        }
+        shared_node_lists
+    }
+
+    fn has_shared_node(entity_ids1: &HashSet<usize>, entity_ids2: &HashSet<usize>) -> bool {
+        return entity_ids1.intersection(&entity_ids2).next() != None;
+    }
+
     /// Convert "SubPatternMatch" to "PatternMatch".
-    // fn pattern_match_conversion(buffer: &mut BinaryHeap<EarliestFirst<'p>>) -> Vec<PatternMatch> {
     fn pattern_match_conversion(buffer: &mut BinaryHeap<EarliestFirst>) -> Vec<PatternMatch> {
         let mut pattern_matches = Vec::with_capacity(buffer.len());
 
@@ -123,7 +211,6 @@
                 .flatten()
                 .enumerate()
             {
-
                 matched_events.extend(event.raw_events.get_ids().map(|id| (idx, id)));
 
                 let (start_time, end_time) = event.raw_events.get_interval();
@@ -146,7 +233,7 @@
     ///
     /// The uniqueness of matches is handled in the next layer (The Uniqueness Layer).
     fn add_to_answer(&mut self) {
-        let root_id = get_root_buffer_id();
+        let root_id = self.get_root_buffer_id();
         self.full_match.extend(Self::pattern_match_conversion(
             &mut self.sub_pattern_buffers[root_id].buffer,
         ));
@@ -173,11 +260,7 @@
     }
 
     /// Join the new matches of the current buffer (`my_id`) with existing matches in its sibling buffer (`sibling_id`).
-    fn join_with_sibling(
-        &mut self,
-        my_id: usize,
-        sibling_id: usize,
-    ) -> BinaryHeap<EarliestFirst> {
+    fn join_with_sibling(&mut self, my_id: usize, sibling_id: usize) -> BinaryHeap<EarliestFirst> {
         debug!(
             "join with sibling: (my_id, sibling_id) = ({}, {})",
             my_id, sibling_id
@@ -199,7 +282,8 @@
                     &sub_pattern_match2.0,
                 ) {
                     matches_to_parent.push(EarliestFirst(merged));
-                    self.num_states += 1
+                    self.num_states += 1;
+
                 } else {
                     debug!(
                         "merge {} and {} failed",
@@ -219,16 +303,16 @@
             debug!("buffer id: {}", buffer_id);
 
             // root reached
-            if buffer_id == get_root_buffer_id() {
+            if buffer_id == self.get_root_buffer_id() {
                 self.add_to_answer();
                 break;
             }
 
             // Clear only the sibling buffer, since we can clear the current buffer when needed (deferred).
-            self.clear_expired(current_time, get_sibling_id(buffer_id));
+            self.clear_expired(current_time, self.get_sibling_id(buffer_id));
 
-            let joined = self.join_with_sibling(buffer_id, get_sibling_id(buffer_id));
-            let parent_id = get_parent_id(buffer_id);
+            let joined = self.join_with_sibling(buffer_id, self.get_sibling_id(buffer_id));
+            let parent_id = self.get_parent_id(buffer_id);
 
             self.sub_pattern_buffers[parent_id]
                 .new_match_buffer
@@ -266,7 +350,7 @@
             if let Some(sub_match) =
                 SubPatternMatch::build(sub_pattern_id, match_instance, num_pat_event)
             {
-                let buffer_id = get_buffer_id(sub_match.id, self.sub_pattern_buffers.len());
+                let buffer_id = get_buffer_id(sub_match.id);
                 let current_time = sub_match.latest_time;
                 // put the sub-pattern match to its corresponding buffer
                 self.sub_pattern_buffers[buffer_id]
@@ -278,52 +362,28 @@
         }
         debug!("full matches: {:#?}", self.full_match.len());
     }
-}
 
-/// Get the corresponding buffer id of a sub-pattern match.
-fn get_buffer_id(sub_pattern_id: usize, buffer_len: usize) -> usize {
-    sub_pattern_id + buffer_len / 2
-}
+    fn get_root_buffer_id(&self) -> usize {
+        self.sub_pattern_buffers.len() - 1
+    }
 
-// /// Get the left buffer id among siblings (might be the buffer indicated by `buffer_id` itself).
-// fn get_left_buffer_id(buffer_id: usize) -> usize {
-//     buffer_id + buffer_id % 2 - 1
-// }
-
-/// Get sibling's buffer id.
-///
-/// Siblings' buffer ids only differ by their LSB.
-fn get_sibling_id(buffer_id: usize) -> usize {
-    // root has no sibling
-    if buffer_id == get_root_buffer_id() {
-        return buffer_id;
-    }
-    if buffer_id % 2 == 0 {
-        buffer_id - 1
-    } else {
-        buffer_id + 1
+    fn get_sibling_id(&self, id: usize) -> usize {
+        self.sibling_id_map[id]
     }
-}
 
-/// Get parent buffer's id.
-fn get_parent_id(buffer_id: usize) -> usize {
-    // root has no parent
-    if buffer_id == get_root_buffer_id() {
-        return buffer_id;
+    fn get_parent_id(&self, id: usize) -> usize {
+        self.parent_id_map[id]
     }
-    // get_left_buffer_id(buffer_id) + 2
-    (buffer_id - 1) / 2
 }
 
-/// Get the root buffer's id.
-fn get_root_buffer_id() -> usize {
-    0
+/// Get the corresponding buffer id of a sub-pattern match.
+fn get_buffer_id(sub_match_id: usize) -> usize {
+    sub_match_id
 }
 
 impl<'p, P> Iterator for JoinLayer<'p, P>
 where
     P: Iterator<Item = (u32, composition_layer::MatchInstance)>,
-    // P: Iterator<Item = (u32, composition_layer::MatchInstance<'p>)>,
 {
     type Item = PatternMatch;
 
@@ -345,12 +405,14 @@
             if let Some(sub_match) =
                 SubPatternMatch::build(sub_pattern_id, match_instance, num_pat_event)
             {
-                let buffer_id = get_buffer_id(sub_match.id, self.sub_pattern_buffers.len());
+                // Note that `sub_match_id` should be identical as `sub_pattern_id`
+                let buffer_id = get_buffer_id(sub_match.id);
                 let current_time = sub_match.latest_time;
                 // put the sub-pattern match to its corresponding buffer
                 self.sub_pattern_buffers[buffer_id]
                     .new_match_buffer
                     .push(EarliestFirst(sub_match));
+                
                 self.num_states += 1;
 
                 self.join(current_time, buffer_id);
@@ -361,6 +423,44 @@
     }
 }
 
+struct UnionFind {
+    roots: Vec<i64>,
+}
+
+impl UnionFind {
+    fn new(size: usize) -> Self {
+        Self {
+            // roots: (0..size).collect_vec()
+            roots: vec![-1; size], // height
+        }
+    }
+
+    fn get_root(&mut self, id: usize) -> usize {
+        if self.roots[id] < 0 {
+            id
+        } else {
+            self.roots[id] = self.get_root(self.roots[id] as usize) as i64;
+            self.roots[id] as usize
+        }
+    }
+
+    fn get_height(&self, id: usize) -> u32 {
+        -self.roots[id] as u32
+    }
+
+    fn merge(&mut self, id1: usize, id2: usize, new_root: usize) {
+        let root1 = self.get_root(id1);
+        let root2 = self.get_root(id2);
+        if root1 == root2 {
+            return;
+        }
+
+        self.roots[new_root] = min(self.roots[root1], self.roots[root2]) - 1;
+        self.roots[root1] = new_root as i64;
+        self.roots[root2] = new_root as i64;
+    }
+}
+
 #[cfg(test)]
 pub mod tests {
     use std::rc::Rc;
@@ -372,25 +472,44 @@
     use crate::{
         pattern::{parser::parse_json, SubPattern},
         process_layers::{composition_layer::MatchInstance, JoinLayer},
-        universal_match_event::UniversalMatchEvent,
     };
     use itertools::{enumerate, Itertools};
     use log::debug;
-    use nix::libc::input_event;
     use serde_json::Value;
     #[test]
     fn test_generate_sub_pattern_buffers() {
         let pattern = Pattern::parse("../data/universal_patterns/SP8_regex.json")
             .expect("Failed to parse pattern");
 
-        let windows_size = 1800 * 1000;
+        let window_size = 1800 * 1000;
         let sub_patterns = decompose(&pattern);
         println!("{:#?}", sub_patterns);
         println!("\n\n");
-        let join_layer = JoinLayer::new((), &pattern, &sub_patterns, windows_size);
+        let join_layer = JoinLayer::new((), &pattern, &sub_patterns, window_size);
         println!("{:#?}", join_layer.sub_pattern_buffers);
     }
 
+    #[test_log::test]
+    fn test_sub_pattern_buffer_shared_node_relation() {
+        let pattern = Pattern::parse("../data/universal_patterns/SP6_regex.json")
+            .expect("Failed to parse pattern");
+
+        let window_size = 1800 * 1000;
+        let sub_patterns = decompose(&pattern);
+        let join_layer = JoinLayer::new((), &pattern, &sub_patterns, window_size);
+
+        debug!("sub_pattern_buffer len: {}", join_layer.sub_pattern_buffers.len());
+        debug!("num of sub_pattern: {}", sub_patterns.len());
+        debug!("sibling id map len: {}", join_layer.sibling_id_map.len());
+
+        for sub_pattern_buffer in &join_layer.sub_pattern_buffers {
+            let sibling_id = join_layer.get_sibling_id(sub_pattern_buffer.id);
+            let sibling_buffer = &join_layer.sub_pattern_buffers[sibling_id];
+
+            assert_ne!(sub_pattern_buffer.node_id_list.intersection(&sibling_buffer.node_id_list).next(), None);
+        }
+    }
+
     /*
        Note:
            The codes here are duplicate to those in benches/join_layer_benchmark.rs,
@@ -406,14 +525,6 @@
         let mut match_events = vec![];
         let mut match_entities = vec![];
         for match_event in &sub_pattern.events {
-            // match_events.push(UniversalMatchEvent {
-            //     matched: *match_event,
-            //     start_time: set_time,
-            //     end_time: set_time,
-            //     subject_id: match_event.subject.id as u64,
-            //     object_id: match_event.object.id as u64,
-            //     event_ids: vec![match_event.id as u64].into_boxed_slice(),
-            // });
 
             let input_event = InputEvent::new(
                 set_time,
@@ -426,9 +537,6 @@
             );
 
             match_events.push(MatchEvent {
-                // matched: *match_event,
-                // start_time: set_time,
-                // end_time: set_time,
                 match_id: match_event.id as u32,
                 input_subject_id: match_event.subject.id as u64,
                 input_object_id: match_event.object.id as u64,
@@ -557,11 +665,9 @@
                     &[0],
                     (9 * i + j + 4) * windows_size + 4 + 2 * j,
                 ));
-                // match_instances.append(&mut gen_match_instances(&sub_patterns, &[2, 3], (9*i+j+4)*windows_size + 3 + 2*j));
-                // match_instances.append(&mut gen_match_instances(&sub_patterns, &[2, 3], (9*i+j+4)*windows_size + 4 + 2*j));
             }
         }
 
         join_layer.run_isolated_join_layer(&mut match_instances);
     }
-}
\ No newline at end of file
+}
