--- ./join_layer/sub_pattern_buffer.rs	2025-03-21 15:16:11.631472088 +0800
+++ ./join_layer/sub_pattern_buffer.rs	2025-03-21 15:16:11.631472088 +0800
@@ -7,7 +7,7 @@
 use std::collections::{BinaryHeap, HashSet};
 use std::rc::Rc;
 
-// use super::{get_parent_id, get_sibling_id};
+use super::{get_parent_id, get_sibling_id};
 
 /// A structure that holds order relations between sibling buffers.
 #[derive(Clone, Debug)]
@@ -79,8 +79,10 @@
 pub struct SubPatternBuffer {
     /// Buffer id.
     pub id: usize,
+    /// Mainly for debugging.
+    sibling_id: usize,
     /// Ids of pattern entities (nodes) contained in this sub-pattern.
-    pub (super) node_id_list: HashSet<usize>,
+    node_id_list: HashSet<usize>,
     /// Ids of pattern events (edges) contained in this sub-pattern.
     edge_id_list: HashSet<usize>,
     /// A buffer that holds sub-pattern matches.
@@ -97,9 +99,11 @@
     pub max_num_events: usize,
 }
 
+// impl<'p> SubPatternBuffer<'p> {
 impl<'p> SubPatternBuffer {
     pub fn new(
         id: usize,
+        sibling_id: usize,
         sub_pattern: &SubPattern,
         max_num_entities: usize,
         max_num_events: usize,
@@ -113,6 +117,7 @@
         }
         Self {
             id,
+            sibling_id,
             node_id_list,
             edge_id_list,
             buffer: BinaryHeap::new(),
@@ -128,6 +133,7 @@
         pattern: &Pattern,
         sub_pattern_buffer1: &SubPatternBuffer,
         sub_pattern_buffer2: &SubPatternBuffer,
+        // distances_table: &HashMap<(NodeIndex, NodeIndex), i32>,
     ) -> Relation {
         let mut shared_entities = vec![false; pattern.entities.len()];
         let mut event_orders = Vec::new();
@@ -160,19 +166,21 @@
         }
     }
 
-    /// Merge two sub-pattern buffers into a new one.
+    /// Merge two sub-pattern buffers.
     pub fn merge_buffers(
         sub_pattern_buffer1: &SubPatternBuffer,
         sub_pattern_buffer2: &SubPatternBuffer,
-        new_buffer_id: usize,
     ) -> Self {
         let mut node_id_list = sub_pattern_buffer1.node_id_list.clone();
         let mut edge_id_list = sub_pattern_buffer1.edge_id_list.clone();
         node_id_list.extend(&sub_pattern_buffer2.node_id_list);
         edge_id_list.extend(&sub_pattern_buffer2.edge_id_list);
 
+        let id = get_parent_id(sub_pattern_buffer1.id);
+
         Self {
-            id: new_buffer_id,
+            id,
+            sibling_id: get_sibling_id(id),
             node_id_list,
             edge_id_list,
             buffer: BinaryHeap::new(),
--- ./join_layer.rs	2025-03-21 15:13:43.368578661 +0800
+++ ./unoptimized_join_layer.rs	2025-03-21 15:12:03.621323672 +0800
@@ -1,18 +1,12 @@
 mod sub_pattern_buffer;
 mod sub_pattern_match;
 
-use crate::pattern::sub_pattern;
 use crate::pattern::Pattern;
 use crate::pattern::SubPattern;
 use crate::pattern_match::PatternMatch;
 use itertools::Itertools;
 use log::debug;
-use std::cmp::max;
-use std::cmp::min;
-use std::cmp::Reverse;
-use std::collections::HashSet;
 use std::collections::{BinaryHeap, HashMap};
-use std::vec;
 pub use sub_pattern_buffer::SubPatternBuffer;
 use sub_pattern_match::EarliestFirst;
 pub use sub_pattern_match::SubPatternMatch;
@@ -40,35 +34,33 @@
     /// Complete pattern matches.
     full_match: Vec<PatternMatch>,
 
-    sibling_id_map: Vec<usize>,
-    parent_id_map: Vec<usize>,
-
     num_states: u64,
 }
 
 impl<'p, P> JoinLayer<'p, P> {
+    /// Create and initialize a pair of sub-pattern buffers.
     fn create_buffer_pair(
-        buffer_id1: usize,
-        buffer_id2: usize,
-        new_buffer_id: usize,
+        buffer_id: usize,
         pattern: &'p Pattern,
-        sub_pattern_buffers: &mut Vec<SubPatternBuffer>,
+        init_buffers: &mut HashMap<usize, SubPatternBuffer>,
     ) {
         let relations = SubPatternBuffer::generate_relations(
             pattern,
-            &sub_pattern_buffers[buffer_id1],
-            &sub_pattern_buffers[buffer_id2],
+            &init_buffers[&buffer_id],
+            &init_buffers[&(buffer_id + 1)],
         );
 
         // update
-        sub_pattern_buffers[buffer_id1].relation = relations.clone();
-        sub_pattern_buffers[buffer_id2].relation = relations;
+        init_buffers.get_mut(&buffer_id).unwrap().relation = relations.clone();
+        init_buffers.get_mut(&(buffer_id + 1)).unwrap().relation = relations;
 
-        sub_pattern_buffers.push(SubPatternBuffer::merge_buffers(
-            &sub_pattern_buffers[buffer_id1],
-            &sub_pattern_buffers[buffer_id2],
-            new_buffer_id,
-        ));
+        init_buffers.insert(
+            get_parent_id(buffer_id),
+            SubPatternBuffer::merge_buffers(
+                &init_buffers[&buffer_id],
+                &init_buffers[&(buffer_id + 1)],
+            ),
+        );
     }
     pub fn new(
         prev_layer: P,
@@ -78,14 +70,16 @@
     ) -> Self {
         let buffer_len = 2 * sub_patterns.len() - 1;
         let mut sub_pattern_buffers = Vec::with_capacity(buffer_len);
-        let mut sibling_id_map = vec![0usize; buffer_len];
-        let mut parent_id_map = vec![0usize; buffer_len];
+        let mut init_buffers = HashMap::new();
 
         for (i, sub_pattern) in sub_patterns.iter().enumerate() {
-            let buffer_id = i;
-            sub_pattern_buffers.push(
+            debug!("pattern.entities.len(): {}", pattern.entities.len());
+            let buffer_id = get_buffer_id(i, buffer_len);
+            init_buffers.insert(
+                buffer_id,
                 SubPatternBuffer::new(
                     buffer_id,
+                    get_sibling_id(buffer_id),
                     sub_pattern,
                     pattern.entities.len(),
                     pattern.events.len(),
@@ -93,61 +87,12 @@
             );
         }
 
-        let mut union_find = UnionFind::new(buffer_len);
-
-        let mut joined = vec![false; buffer_len];
-
-        let mut min_heap = BinaryHeap::new();
-        let shared_node_lists = Self::gen_shared_node_lists(sub_patterns);
-        for (i, list) in shared_node_lists.iter().enumerate() {
-            for j in list {
-                // avoid duplicates
-                if *j <= i {
-                    continue;
-                }
-                min_heap.push(Reverse((2u32, i, *j)));
-            }
+        for buffer_id in (1..buffer_len - 1).step_by(2).rev() {
+            Self::create_buffer_pair(buffer_id, pattern, &mut init_buffers);
         }
 
-        while let Some(Reverse((height, i, j))) = min_heap.pop() {
-            if joined[i] || joined[j] {
-                continue;
-            }
-
-            joined[i] = true;
-            joined[j] = true;
-
-            let new_buffer_id = sub_pattern_buffers.len();
-            Self::create_buffer_pair(i, j, new_buffer_id, pattern, &mut sub_pattern_buffers);
-            sibling_id_map[i] = j;
-            sibling_id_map[j] = i;
-            parent_id_map[i] = new_buffer_id;
-            parent_id_map[j] = new_buffer_id;
-
-            debug!("buffer {} and buffer {} are merged into buffer {}", i, j, new_buffer_id);
-
-            union_find.merge(i, j, new_buffer_id);
-
-            let mut visited = HashSet::new();
-            visited.insert(new_buffer_id);
-            for k in 0..sub_patterns.len() {
-                let cur_root = union_find.get_root(k);
-                if visited.contains(&cur_root) {
-                    continue;
-                }
-
-                // there might be duplicate `cur_root`
-                for id in &shared_node_lists[k] {
-                    // has shared node relation
-                    if union_find.get_root(*id) == new_buffer_id {
-                        let new_height = max(height, union_find.get_height(cur_root)) + 1;
-                        min_heap.push(Reverse((new_height, new_buffer_id, cur_root)));
-
-                        visited.insert(cur_root);
-                        break;
-                    }
-                }
-            }
+        for buffer_id in 0..buffer_len {
+            sub_pattern_buffers.push(init_buffers[&buffer_id].clone());
         }
 
         Self {
@@ -156,45 +101,12 @@
             sub_pattern_buffers,
             window_size,
             full_match: Vec::new(),
-            sibling_id_map,
-            parent_id_map,
             num_states: 0,
         }
     }
 
-    fn gen_shared_node_lists(sub_patterns: &[SubPattern<'p>]) -> Vec<Vec<usize>> {
-        let mut shared_node_lists = vec![Vec::new(); sub_patterns.len()];
-        for (i, sub_pattern1) in sub_patterns.iter().enumerate() {
-            let entity_ids1: HashSet<usize> = sub_pattern1
-                .events
-                .iter()
-                .flat_map(|e| [e.subject.id, e.object.id])
-                .collect();
-            for (j, sub_pattern2) in sub_patterns.iter().enumerate() {
-                if j <= i {
-                    continue;
-                }
-                let entity_ids2: HashSet<usize> = sub_pattern2
-                    .events
-                    .iter()
-                    .flat_map(|e| [e.subject.id, e.object.id])
-                    .collect();
-                // let entity_ids2 = sub_pattern2.events.iter().flat_map(|e| [e.subject.id, e.object.id]).sorted().unique().collect_vec();
-
-                if Self::has_shared_node(&entity_ids1, &entity_ids2) {
-                    shared_node_lists[i].push(j);
-                    shared_node_lists[j].push(i);
-                }
-            }
-        }
-        shared_node_lists
-    }
-
-    fn has_shared_node(entity_ids1: &HashSet<usize>, entity_ids2: &HashSet<usize>) -> bool {
-        return entity_ids1.intersection(&entity_ids2).next() != None;
-    }
-
     /// Convert "SubPatternMatch" to "PatternMatch".
+    // fn pattern_match_conversion(buffer: &mut BinaryHeap<EarliestFirst<'p>>) -> Vec<PatternMatch> {
     fn pattern_match_conversion(buffer: &mut BinaryHeap<EarliestFirst>) -> Vec<PatternMatch> {
         let mut pattern_matches = Vec::with_capacity(buffer.len());
 
@@ -211,6 +123,7 @@
                 .flatten()
                 .enumerate()
             {
+
                 matched_events.extend(event.raw_events.get_ids().map(|id| (idx, id)));
 
                 let (start_time, end_time) = event.raw_events.get_interval();
@@ -233,7 +146,7 @@
     ///
     /// The uniqueness of matches is handled in the next layer (The Uniqueness Layer).
     fn add_to_answer(&mut self) {
-        let root_id = self.get_root_buffer_id();
+        let root_id = get_root_buffer_id();
         self.full_match.extend(Self::pattern_match_conversion(
             &mut self.sub_pattern_buffers[root_id].buffer,
         ));
@@ -260,7 +173,11 @@
     }
 
     /// Join the new matches of the current buffer (`my_id`) with existing matches in its sibling buffer (`sibling_id`).
-    fn join_with_sibling(&mut self, my_id: usize, sibling_id: usize) -> BinaryHeap<EarliestFirst> {
+    fn join_with_sibling(
+        &mut self,
+        my_id: usize,
+        sibling_id: usize,
+    ) -> BinaryHeap<EarliestFirst> {
         debug!(
             "join with sibling: (my_id, sibling_id) = ({}, {})",
             my_id, sibling_id
@@ -282,8 +199,7 @@
                     &sub_pattern_match2.0,
                 ) {
                     matches_to_parent.push(EarliestFirst(merged));
-                    self.num_states += 1;
-
+                    self.num_states += 1
                 } else {
                     debug!(
                         "merge {} and {} failed",
@@ -303,16 +219,16 @@
             debug!("buffer id: {}", buffer_id);
 
             // root reached
-            if buffer_id == self.get_root_buffer_id() {
+            if buffer_id == get_root_buffer_id() {
                 self.add_to_answer();
                 break;
             }
 
             // Clear only the sibling buffer, since we can clear the current buffer when needed (deferred).
-            self.clear_expired(current_time, self.get_sibling_id(buffer_id));
+            self.clear_expired(current_time, get_sibling_id(buffer_id));
 
-            let joined = self.join_with_sibling(buffer_id, self.get_sibling_id(buffer_id));
-            let parent_id = self.get_parent_id(buffer_id);
+            let joined = self.join_with_sibling(buffer_id, get_sibling_id(buffer_id));
+            let parent_id = get_parent_id(buffer_id);
 
             self.sub_pattern_buffers[parent_id]
                 .new_match_buffer
@@ -350,7 +266,7 @@
             if let Some(sub_match) =
                 SubPatternMatch::build(sub_pattern_id, match_instance, num_pat_event)
             {
-                let buffer_id = get_buffer_id(sub_match.id);
+                let buffer_id = get_buffer_id(sub_match.id, self.sub_pattern_buffers.len());
                 let current_time = sub_match.latest_time;
                 // put the sub-pattern match to its corresponding buffer
                 self.sub_pattern_buffers[buffer_id]
@@ -362,28 +278,52 @@
         }
         debug!("full matches: {:#?}", self.full_match.len());
     }
+}
 
-    fn get_root_buffer_id(&self) -> usize {
-        self.sub_pattern_buffers.len() - 1
-    }
+/// Get the corresponding buffer id of a sub-pattern match.
+fn get_buffer_id(sub_pattern_id: usize, buffer_len: usize) -> usize {
+    sub_pattern_id + buffer_len / 2
+}
 
-    fn get_sibling_id(&self, id: usize) -> usize {
-        self.sibling_id_map[id]
+// /// Get the left buffer id among siblings (might be the buffer indicated by `buffer_id` itself).
+// fn get_left_buffer_id(buffer_id: usize) -> usize {
+//     buffer_id + buffer_id % 2 - 1
+// }
+
+/// Get sibling's buffer id.
+///
+/// Siblings' buffer ids only differ by their LSB.
+fn get_sibling_id(buffer_id: usize) -> usize {
+    // root has no sibling
+    if buffer_id == get_root_buffer_id() {
+        return buffer_id;
+    }
+    if buffer_id % 2 == 0 {
+        buffer_id - 1
+    } else {
+        buffer_id + 1
     }
+}
 
-    fn get_parent_id(&self, id: usize) -> usize {
-        self.parent_id_map[id]
+/// Get parent buffer's id.
+fn get_parent_id(buffer_id: usize) -> usize {
+    // root has no parent
+    if buffer_id == get_root_buffer_id() {
+        return buffer_id;
     }
+    // get_left_buffer_id(buffer_id) + 2
+    (buffer_id - 1) / 2
 }
 
-/// Get the corresponding buffer id of a sub-pattern match.
-fn get_buffer_id(sub_match_id: usize) -> usize {
-    sub_match_id
+/// Get the root buffer's id.
+fn get_root_buffer_id() -> usize {
+    0
 }
 
 impl<'p, P> Iterator for JoinLayer<'p, P>
 where
     P: Iterator<Item = (u32, composition_layer::MatchInstance)>,
+    // P: Iterator<Item = (u32, composition_layer::MatchInstance<'p>)>,
 {
     type Item = PatternMatch;
 
@@ -405,14 +345,12 @@
             if let Some(sub_match) =
                 SubPatternMatch::build(sub_pattern_id, match_instance, num_pat_event)
             {
-                // Note that `sub_match_id` should be identical as `sub_pattern_id`
-                let buffer_id = get_buffer_id(sub_match.id);
+                let buffer_id = get_buffer_id(sub_match.id, self.sub_pattern_buffers.len());
                 let current_time = sub_match.latest_time;
                 // put the sub-pattern match to its corresponding buffer
                 self.sub_pattern_buffers[buffer_id]
                     .new_match_buffer
                     .push(EarliestFirst(sub_match));
-                
                 self.num_states += 1;
 
                 self.join(current_time, buffer_id);
@@ -423,44 +361,6 @@
     }
 }
 
-struct UnionFind {
-    roots: Vec<i64>,
-}
-
-impl UnionFind {
-    fn new(size: usize) -> Self {
-        Self {
-            // roots: (0..size).collect_vec()
-            roots: vec![-1; size], // height
-        }
-    }
-
-    fn get_root(&mut self, id: usize) -> usize {
-        if self.roots[id] < 0 {
-            id
-        } else {
-            self.roots[id] = self.get_root(self.roots[id] as usize) as i64;
-            self.roots[id] as usize
-        }
-    }
-
-    fn get_height(&self, id: usize) -> u32 {
-        -self.roots[id] as u32
-    }
-
-    fn merge(&mut self, id1: usize, id2: usize, new_root: usize) {
-        let root1 = self.get_root(id1);
-        let root2 = self.get_root(id2);
-        if root1 == root2 {
-            return;
-        }
-
-        self.roots[new_root] = min(self.roots[root1], self.roots[root2]) - 1;
-        self.roots[root1] = new_root as i64;
-        self.roots[root2] = new_root as i64;
-    }
-}
-
 #[cfg(test)]
 pub mod tests {
     use std::rc::Rc;
@@ -472,44 +372,25 @@
     use crate::{
         pattern::{parser::parse_json, SubPattern},
         process_layers::{composition_layer::MatchInstance, JoinLayer},
+        universal_match_event::UniversalMatchEvent,
     };
     use itertools::{enumerate, Itertools};
     use log::debug;
+    use nix::libc::input_event;
     use serde_json::Value;
     #[test]
     fn test_generate_sub_pattern_buffers() {
         let pattern = Pattern::parse("../data/universal_patterns/SP8_regex.json")
             .expect("Failed to parse pattern");
 
-        let window_size = 1800 * 1000;
+        let windows_size = 1800 * 1000;
         let sub_patterns = decompose(&pattern);
         println!("{:#?}", sub_patterns);
         println!("\n\n");
-        let join_layer = JoinLayer::new((), &pattern, &sub_patterns, window_size);
+        let join_layer = JoinLayer::new((), &pattern, &sub_patterns, windows_size);
         println!("{:#?}", join_layer.sub_pattern_buffers);
     }
 
-    #[test_log::test]
-    fn test_sub_pattern_buffer_shared_node_relation() {
-        let pattern = Pattern::parse("../data/universal_patterns/SP6_regex.json")
-            .expect("Failed to parse pattern");
-
-        let window_size = 1800 * 1000;
-        let sub_patterns = decompose(&pattern);
-        let join_layer = JoinLayer::new((), &pattern, &sub_patterns, window_size);
-
-        debug!("sub_pattern_buffer len: {}", join_layer.sub_pattern_buffers.len());
-        debug!("num of sub_pattern: {}", sub_patterns.len());
-        debug!("sibling id map len: {}", join_layer.sibling_id_map.len());
-
-        for sub_pattern_buffer in &join_layer.sub_pattern_buffers {
-            let sibling_id = join_layer.get_sibling_id(sub_pattern_buffer.id);
-            let sibling_buffer = &join_layer.sub_pattern_buffers[sibling_id];
-
-            assert_ne!(sub_pattern_buffer.node_id_list.intersection(&sibling_buffer.node_id_list).next(), None);
-        }
-    }
-
     /*
        Note:
            The codes here are duplicate to those in benches/join_layer_benchmark.rs,
@@ -525,6 +406,14 @@
         let mut match_events = vec![];
         let mut match_entities = vec![];
         for match_event in &sub_pattern.events {
+            // match_events.push(UniversalMatchEvent {
+            //     matched: *match_event,
+            //     start_time: set_time,
+            //     end_time: set_time,
+            //     subject_id: match_event.subject.id as u64,
+            //     object_id: match_event.object.id as u64,
+            //     event_ids: vec![match_event.id as u64].into_boxed_slice(),
+            // });
 
             let input_event = InputEvent::new(
                 set_time,
@@ -537,6 +426,9 @@
             );
 
             match_events.push(MatchEvent {
+                // matched: *match_event,
+                // start_time: set_time,
+                // end_time: set_time,
                 match_id: match_event.id as u32,
                 input_subject_id: match_event.subject.id as u64,
                 input_object_id: match_event.object.id as u64,
@@ -665,9 +557,11 @@
                     &[0],
                     (9 * i + j + 4) * windows_size + 4 + 2 * j,
                 ));
+                // match_instances.append(&mut gen_match_instances(&sub_patterns, &[2, 3], (9*i+j+4)*windows_size + 3 + 2*j));
+                // match_instances.append(&mut gen_match_instances(&sub_patterns, &[2, 3], (9*i+j+4)*windows_size + 4 + 2*j));
             }
         }
 
         join_layer.run_isolated_join_layer(&mut match_instances);
     }
-}
+}
\ No newline at end of file
